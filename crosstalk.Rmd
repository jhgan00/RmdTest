---
title: "Crosstalk"
author: "Jeonghyun Gan"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

모든 내용은 [Rsudio Crosstalk Github](https://rstudio.github.io/crosstalk)를 참고하여 작성되었습니다.

## 1. About Crosstalk

Crosstalk은 `htmlwidgets`의 add-on 패키지이며, Shared data를 바탕으로 HTML 위젯 간의 상호작용(linked brushing, filtering 등) 기능을 구현하였다.


Crosstalk은 데이터프레임을 입력을 받는 HTML 위젯들에서 작동하며, 이번 실습에서는 `d3scatter` 패키지와 `leaflet` 패키지를 활용한다. Crosstalk은 별다른 런타임 의존성을 갖지 않는다는 장점이 있다. 즉 단순히 Rmarkdown과 Crosstalk만을 가지고도 아마존S3, 깃허브, RPubs 등에 호스팅될 수 있는 정적 HTML 문서를 생산 가능하다. Crosstalk의 주요한 한계점들은 다음과 같다.

1. **저작자가 직접 HTML 위젯을 적절히 수정해야 한다**. Crosstalk은 스스로 위젯들을 연동시켜주지는 않는다.

2. 현재로써는, **Crosstalk은 개별 data point에 대해서만 작동하며, 데이터의 결합이나 요약을 표현하는 위젯들에는 작동하지 않는다.** 예를 들어서 개별 data point를 표현하는 산점도에는 Crosstalk이 적용될 수 있지만, 히스토그램에는 Crosstalk이 적용될 수 없다.

3. Crosstalk은 **큰 데이터에 적합하지 않다**. 모든 데이터가 브라우저에 로드되어야 하기 때문이다.

## 2. Using Crosstalk

Crosstalk 하나의 Rmarkdown 문서 혹은 Shiny 앱에서 여러 위젯의 연동 기능을 제공한다. 하지만 아직은 Crosstalk과 연동 가능한 HTML 위젯은 제한적이다. 이번 절에서는 Rmarkdown과 `d3scatter`, `leaflet` 패키지를 통해서 실습을 진행한다. 먼저 깃허브에서 `crosstalk`, `d3scatter`, `leaflet` 패키지를 다운로드하고 불러온다.

```{r eval=F}
devtools::install_github("rstudio/crosstalk")
devtools::install_github("jcheng5/d3scatter")
devtools::install_github("rstudio/leaflet")
```

```{r message=F, warning=F}
library(crosstalk) 
library(d3scatter)
library(leaflet)
```

Crosstalk은 데이터프레임(혹은 데이터프레임과 유사한 객체)을 입력으로 받는 HTML 위젯들에서 작동하도록 설계되었다. 예를 들면, `d3catter` 패키지는 다음과 같이 데이터프레임을 입력으로 받는다.

```{r}
d3scatter(iris, ~Petal.Length, ~Petal.Width, ~Species)
```

이제 `crosstalk`을 활용하여 플롯을 구성해보자. 먼저 `SharedData` 클래스로 데이터프레임을 감싸주고, 이 결과물을 HTML 위젯에 전달해주면 된다. 코드는 다음과 같다.

```{r}
shared_iris = SharedData$new(iris)
d3scatter(shared_iris, ~Petal.Length, ~Petal.Width, ~Species)
```

### Linked Brusing

이제 서로 다른 두 개의 위젯에 `SharedData`를 전달해보자. SharedData를 구성한 후, d3scatter에 전달해서 그래프를 그리고, bscols를 이용하여 두 개의 플롯을 옆으로 배열한다. 하나의 플롯에서 브러싱을 해보면, 옆의 플롯에도 동일한 data point에 브러싱이 적용되는 것을 알 수 있다. 이는 두 플롯이 하나의 SharedData에 기반하여 만들어지기 때문에 가능하다. 만약 두 개의 다른 SharedData를 각각의 `d3scatter` 플롯에 전달한다면, 링크가 작동하지 않는다.

```{r}
shared_iris = SharedData$new(iris)

bscols(
  d3scatter(shared_iris, ~Petal.Length, ~Petal.Width, ~Species, width="100%", height=300),
  d3scatter(shared_iris, ~Sepal.Length, ~Sepal.Width, ~Species, width="100%", height=300)
)
```

Crosstalk은 두 개 이상의 위젯, 혹은 서로 다른 타입의 위젯(예를 들면 지도와 산점도)들을 연동시키는 것도 가능하다. Crosstalk과 연동되는 모든 위젯들은 서로 연결될 수 있다. 다음은 `leaflet` 패키지를 이용한 지도와 `d3scatter` 패키지를 이용한 산점도를 연동시킨 예제이다. `quakes` 데이터프레임에서 100개의 데이터를 샘플링하고, 이를 `SharedData` 클래스로 감싼다. 이 객체를 `leaflet`과 `descatter`에 각각 전달하여 두 개의 플롯을 생성하고, `bscols()`함수를 활용하여 옆으로 배열해준다. 지도 혹은 산점도에서 브러슁을 적용하면, 반대편에서도 브러슁이 적용되는 것을 확인할 수 있다.

```{r}
shared_quakes = SharedData$new(quakes[sample(nrow(quakes),100),])
bscols(
  leaflet(shared_quakes, width="100%", height=300) %>%
    addTiles() %>%
    addMarkers(),
  d3scatter(shared_quakes, ~depth, ~mag, width="100%", height=300)
)
```

### Filters